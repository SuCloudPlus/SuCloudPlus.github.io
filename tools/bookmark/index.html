<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="robots" content="noindex, nofollow">
    <title>加密书签管理器</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="/assets/config.js"></script>
    <link rel="stylesheet" href="/assets/style_bookmark.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
/* 认证界面 */
.auth-container {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.auth-box {
    background-color: var(--card-bg);
    padding: 30px;
    border-radius: 8px;
    width: 100%;
    max-width: 400px;
    text-align: center;
    border: 1px solid var(--border-color);
}

.auth-title {
    color: var(--primary-color);
    margin-bottom: 20px;
    font-size: 1.4rem;
}
</style>
</head>
<body>
    <!-- 提示框容器 -->
    <div id="toast-container" class="toast-container"></div>

<!-- 移动端遮罩层 -->
<div id="mobile-overlay" class="overlay" onclick="toggleSidebar()"></div>

<!-- 认证界面 -->
<div id="auth-container" class="auth-container">
    <div class="auth-box">
        <h2 class="auth-title"><i class="fas fa-lock"></i> 加密书签管理器</h2>
            <div class="form-row">
                <input type="password" id="password" placeholder="输入密码..." autocomplete="current-password">
                    </div>
<button id="login-btn" class="btn"><i class="fas fa-lock-open"></i> 解锁 / 创建</button>
<div id="auth-loader" class="loader hidden"></div>
<p id="auth-error" class="error-message"></p>
</div>
</div>

<!-- 主应用界面 -->
<div id="app-container" class="hidden">
    <div class="header">
        <button class="mobile-menu-btn" onclick="toggleSidebar()">
            <i class="fas fa-bars"></i>
</button>
<h1><i class="fas fa-bookmark"></i> 加密书签</h1>
    <div class="header-controls">
        <button id="theme-toggle" class="theme-toggle" onclick="toggleTheme()">
            <i class="fas fa-moon"></i>
</button>
<button id="logout-btn" class="btn"><i class="fas fa-lock"></i> 锁定</button>
    </div>
</div>

<div class="main-container">
    <!-- 左侧目录树 -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <span><i class="fas fa-folder-tree"></i> 目录</span>
                </div>
<div class="folder-tree-container">
    <ul class="folder-tree" id="folder-tree">
        <!-- 目录树通过JS动态生成 -->
        </ul>
<div style="border-top: 1px solid var(--border-color); margin-top: 10px; padding-top: 10px;">
    <div class="folder-item" data-id="trash" onclick="selectFolder('trash')">
        <span class="folder-icon"><i class="fas fa-trash"></i></span>
            <span class="folder-name">回收站</span>
<span class="folder-stats">${trash.length}</span>
</div>
</div>
</div>
</div>

<!-- 右侧内容区域 -->
<div class="content">
    <div class="toolbar">
        <div class="current-folder">
            <i id="current-folder-icon" class="fas fa-folder-open"></i>
<span id="current-folder-name">所有书签</span>
</div>
<div class="btn-group">
    <button id="add-bookmark-btn" class="btn"><i class="fas fa-plus"></i> 添加书签</button>
        <button id="add-folder-btn" class="btn"><i class="fas fa-folder-plus"></i> 添加文件夹</button>
            <button id="open-all-btn" class="btn btn-outline"><i class="fas fa-external-link-alt"></i> 打开全部</button>
                </div>
</div>

<div class="folder-path" id="folder-path">
    <!-- 路径导航通过JS动态生成 -->
    </div>

<div class="subfolders-container" id="subfolders-container">
    <!-- 子文件夹通过JS动态生成 -->
    </div>

<div class="bookmark-list-container">
    <table class="bookmark-table">
        <thead id="bookmark-table-header">
            <tr>
            <th style="width: 5%;"></th>
<th style="width: 10%;">序号</th>
<th style="width: 20%;">网站名称</th>
<th style="width: 30%;">描述</th>
<th style="width: 25%;">网址</th>
<th style="width: 10%; text-align: right;">操作</th>
</tr>
</thead>
<tbody id="bookmark-list">
    <!-- 书签列表通过JS动态生成 -->
    </tbody>
</table>
</div>
</div>
</div>
</div>

<!-- 书签表单 -->
<div id="bookmark-form-container" class="form-container">
    <div class="add-form">
        <h3 id="bookmark-form-title" style="margin-bottom: 20px; color: var(--primary-color);"></h3>
<input type="hidden" id="bm-id">
    <div class="form-row">
        <label for="bm-title"><i class="fas fa-heading"></i> 书签标题</label>
            <input type="text" id="bm-title" placeholder="输入书签标题" required>
                </div>
<div class="form-row">
    <label for="bm-description"><i class="fas fa-comment-alt"></i> 网站描述</label>
        <textarea id="bm-description" rows="3" placeholder="选填：描述网站功能..."></textarea>
</div>
<div class="form-row">
    <label for="bm-url"><i class="fas fa-link"></i> 书签网址</label>
        <input type="url" id="bm-url" placeholder="https://..." required>
            </div>
<div class="form-row">
    <label for="bm-folder"><i class="fas fa-folder"></i> 文件夹</label>
        <select id="bm-folder">
            <!-- 文件夹选项通过JS动态生成 -->
            </select>
</div>
<div class="form-actions">
    <button id="cancel-bookmark-form" class="btn btn-outline">取消</button>
<button id="save-bookmark-form" class="btn">保存</button>
</div>
</div>
</div>

<!-- 文件夹表单 -->
<div id="folder-form-container" class="form-container">
    <div class="add-form">
        <h3 id="folder-form-title" style="margin-bottom: 20px; color: var(--primary-color);"></h3>
<input type="hidden" id="folder-id">
    <div class="form-row">
        <label for="folder-name"><i class="fas fa-folder"></i> 文件夹名称</label>
            <input type="text" id="folder-name" placeholder="输入文件夹名称">
                </div>
<div class="form-row">
    <label for="parent-folder"><i class="fas fa-sitemap"></i> 父文件夹</label>
        <select id="parent-folder">
            <!-- 父文件夹选项通过JS动态生成 -->
            </select>
</div>
<div class="form-actions">
    <button id="cancel-folder-form" class="btn btn-outline">取消</button>
<button id="save-folder-form" class="btn">保存</button>
</div>
</div>
</div>

<script>
// ==================== 用户加密配置 ====================
const ENCRYPTED_CONFIG = ENCRYPTED_CONFIG_bookmark;

// ==================== DOM元素 ====================
const authContainer = document.getElementById('auth-container');
const appContainer = document.getElementById('app-container');
const passwordInput = document.getElementById('password');
const loginBtn = document.getElementById('login-btn');
const logoutBtn = document.getElementById('logout-btn');
const authLoader = document.getElementById('auth-loader');
const authError = document.getElementById('auth-error');
const bookmarkList = document.getElementById('bookmark-list');
const bookmarkTableHeader = document.getElementById('bookmark-table-header');
const folderTree = document.getElementById('folder-tree');
const currentFolderName = document.getElementById('current-folder-name');
const currentFolderIcon = document.getElementById('current-folder-icon');
const folderPath = document.getElementById('folder-path');
const subfoldersContainer = document.getElementById('subfolders-container');
const addBookmarkBtn = document.getElementById('add-bookmark-btn');
const addFolderBtn = document.getElementById('add-folder-btn');
const openAllBtn = document.getElementById('open-all-btn');
const toastContainer = document.getElementById('toast-container');
const sidebar = document.getElementById('sidebar');
const mobileOverlay = document.getElementById('mobile-overlay');
const themeToggle = document.getElementById('theme-toggle');

// 表单元素
const bookmarkFormContainer = document.getElementById('bookmark-form-container');
const folderFormContainer = document.getElementById('folder-form-container');
const bmFolderSelect = document.getElementById('bm-folder');
const parentFolderSelect = document.getElementById('parent-folder');

// ==================== 全局变量 ====================
let encryptionKey = null;
let bookmarks = [];
let folders = [];
let trash = [];
let currentFolderId = 'root';
let folderPathMap = {};
let draggedItem = null;
let dragOverItem = null;
let isSaving = false;

// ==================== 工具函数 ====================
/** 生成唯一ID */
function generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
}

/** 加密文本 */
function encrypt(text, key) {
    return CryptoJS.AES.encrypt(text, key).toString();
}

/** 解密文本 */
function decrypt(ciphertext, key) {
    try {
        const bytes = CryptoJS.AES.decrypt(ciphertext, key);
        return bytes.toString(CryptoJS.enc.Utf8);
    } catch (e) {
        return '';
    }
}

/** 显示提示消息 */
function showToast(message, type = 'info', duration = 3000) {
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    const icons = {
        'error': 'fa-exclamation-circle',
        'success': 'fa-check-circle',
        'warning': 'fa-exclamation-triangle',
        'info': 'fa-info-circle'
    };

    toast.innerHTML = `
                <i class="fas ${icons[type]} toast-icon"></i>
                <div class="toast-message">${message}</div>
            `;

            toastContainer.appendChild(toast);
            setTimeout(() => toast.classList.add('show'), 10);

            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

/** 切换加载状态 */
function toggleLoader(loader, show) {
    loader.classList.toggle('hidden', !show);
}

/** 隐藏所有表单 */
function hideAllForms() {
    bookmarkFormContainer.classList.remove('active');
    folderFormContainer.classList.remove('active');
}

// ==================== 主题切换 ====================
function toggleTheme() {
    const isLight = document.body.classList.toggle('light-mode');
    const icon = themeToggle.querySelector('i');
    icon.className = isLight ? 'fas fa-sun' : 'fas fa-moon';
    localStorage.setItem('bookmark-theme', isLight ? 'light' : 'dark');
    showToast(`已切换到${isLight ? '浅色' : '深色'}模式`, 'success', 1500);
}

/** 初始化主题 */
function initTheme() {
    const savedTheme = localStorage.getItem('bookmark-theme') || 'dark';
    if (savedTheme === 'light') {
        document.body.classList.add('light-mode');
        themeToggle.querySelector('i').className = 'fas fa-sun';
    }
}

// ==================== 移动端适配 ====================
function toggleSidebar() {
    sidebar.classList.toggle('show');
    mobileOverlay.classList.toggle('show');
}

function closeSidebar() {
    sidebar.classList.remove('show');
    mobileOverlay.classList.remove('show');
}

// ==================== API操作 ====================
/** 使用动态配置获取Gist数据 */
async function fetchGistWithConfig(gistUrl, githubToken) {
    try {
        const response = await fetch(gistUrl, {
            headers: { 'Authorization': `token ${githubToken}` }
        });
        if (!response.ok) {
            console.error('GitHub API错误:', response.status, response.statusText);
            throw new Error(`GitHub API错误: ${response.statusText}`);
        }
        const gist = await response.json();
        if (!gist.files || !gist.files['bookmarks.json']) {
            showToast('Gist中未找到数据文件', 'warning');
            return '{}';
        }
        return gist.files['bookmarks.json'].content;
    } catch (error) {
        console.error('获取数据失败:', error);
        showToast('获取数据失败，请检查配置和网络', 'error');
        return null;
    }
}

/** 使用动态配置更新Gist */
async function updateGistWithConfig(gistUrl, githubToken) {
    if (isSaving) {
        console.log('正在保存中，跳过重复请求');
        return false;
    }
    
    isSaving = true;
    
    try {
        const data = {
            folders: folders.map(f => ({ ...f, order: f.order || 0 })),
            bookmarks: bookmarks.map(b => ({ 
                ...b, 
                order: b.order || 0, 
                description: b.description || '' 
            })),
            trash
        };
        
        console.log('准备保存数据到:', gistUrl);
        console.log('数据条数 - 文件夹:', folders.length, '书签:', bookmarks.length);
        
        const encryptedData = encrypt(JSON.stringify(data), encryptionKey);
        
        const response = await fetch(gistUrl, {
            method: 'PATCH',
            headers: {
                'Authorization': `token ${githubToken}`,
                'Content-Type': 'application/json',
                'Accept': 'application/vnd.github.v3+json'
            },
            body: JSON.stringify({
                description: "加密书签管理器数据",
                files: { 
                    'bookmarks.json': { 
                        content: encryptedData 
                    } 
                }
            })
        });
        
        console.log('保存响应状态:', response.status);
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error('保存失败响应:', errorText);
            throw new Error(`更新失败: ${response.status} ${response.statusText}`);
        }
        
        const result = await response.json();
        console.log('保存成功:', result.id);
        return true;
        
    } catch (error) {
        console.error('保存失败详情:', error);
        showToast(`保存失败: ${error.message}`, 'error');
        return false;
    } finally {
        isSaving = false;
    }
}

// ==================== 数据操作 ====================
/** 保存并刷新界面 */
async function saveAndRender() {
    renderApp();
    
    // 检查是否有当前的Gist配置
    if (window.currentGistConfig && encryptionKey) {
        try {
            const success = await updateGistWithConfig(
                window.currentGistConfig.url,
                window.currentGistConfig.token
            );
            
            if (success) {
                // 可以添加一个简短的成功提示，但不要太频繁
                console.log('数据保存成功');
            } else {
                console.log('保存失败，但没有抛出异常');
            }
        } catch (error) {
            console.error('保存失败:', error);
            // 不要每次都显示错误提示，避免干扰用户体验
            // 只在用户操作时显示特定错误
        }
    } else {
        console.error('无法保存：缺少配置或加密密钥');
        console.log('currentGistConfig:', window.currentGistConfig);
        console.log('encryptionKey:', encryptionKey ? '已设置' : '未设置');
    }
}

/** 构建文件夹路径映射 */
function buildFolderPathMap() {
    folderPathMap = { 'root': [{ id: 'root', name: '所有书签' }] };

    const buildPath = (folderId, path) => {
        const folder = folders.find(f => f.id === folderId);
        if (!folder) return;

        const currentPath = [...path, { id: folder.id, name: folder.name }];
        folderPathMap[folder.id] = currentPath;

        folders.filter(f => f.parentId === folderId).forEach(child => {
            buildPath(child.id, currentPath);
        });
    };

    folders.filter(f => f.parentId === 'root').forEach(f => {
        buildPath(f.id, [{ id: 'root', name: '所有书签' }]);
    });
}

/** 获取文件夹路径 */
function getFolderPath(folderId) {
    return folderPathMap[folderId] || [{ id: 'root', name: '所有书签' }];
}

/** 计算文件夹统计信息 */
function getFolderStats(folderId) {
    const subfolders = folders.filter(f => f.parentId === folderId).length;
    const subbookmarks = bookmarks.filter(b => b.folderId === folderId).length;
    return { subfolders, subbookmarks };
}

// ==================== 界面渲染 ====================
/** 渲染整个应用 */
function renderApp() {
    buildFolderPathMap();
    renderFolderTreeUI();
    selectFolder(currentFolderId, true);
}

/** 渲染目录树 */
function renderFolderTreeUI() {
    const renderChildren = (parentId, level) => {
        const children = folders.filter(f => f.parentId === parentId)
        .sort((a, b) => (a.order || 0) - (b.order || 0));

        if (children.length === 0) return '';

        return children.map(folder => {
            const isActive = folder.id === currentFolderId;
            const hasChildren = folders.some(f => f.parentId === folder.id);
            const isExpanded = folder.expanded || false;
            const stats = getFolderStats(folder.id);

            return `
                    <li>
                        <div class="folder-item tree-level-${level} ${isActive ? 'active' : ''}" 
                             data-id="${folder.id}"
                             draggable="true"
                             ondragstart="onFolderDragStart(event, '${folder.id}')"
                             ondragover="onFolderDragOver(event, '${folder.id}')"
                             ondragleave="onFolderDragLeave(event, '${folder.id}')"
                             ondrop="onFolderDrop(event, '${folder.id}')"
                             onclick="selectFolder('${folder.id}')">
                            <div class="drag-handle" onclick="event.stopPropagation()">
                                <i class="fas fa-grip-vertical"></i>
                            </div>
                            <div class="folder-toggle ${hasChildren ? '' : 'empty'}" onclick="event.stopPropagation(); toggleFolderExpand('${folder.id}')">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <span class="folder-icon">
                                <i class="fas ${isExpanded && hasChildren ? 'fa-folder-open' : 'fa-folder'}"></i>
                            </span>
                            <span class="folder-name">${folder.name}</span>
                            <span class="folder-stats">${stats.subfolders}/${stats.subbookmarks}</span>
                        </div>
                        <ul class="folder-children" id="${folder.id}-children" style="${isExpanded ? 'display: block;' : 'display: none;'}">
                            ${renderChildren(folder.id, level + 1)}
                        </ul>
                    </li>`;
                }).join('');
            };

            const isRootActive = currentFolderId === 'root';
            const rootHasChildren = folders.some(f => f.parentId === 'root');
            const rootStats = getFolderStats('root');

            folderTree.innerHTML = `
                <li>
                    <div class="folder-item tree-level-0 ${isRootActive ? 'active' : ''}" 
                         data-id="root"
                         onclick="selectFolder('root')">
                        <div class="folder-toggle ${rootHasChildren ? '' : 'empty'}" onclick="event.stopPropagation(); toggleFolderExpand('root')">
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <span class="folder-icon"><i class="fas fa-folder-open"></i></span>
                        <span class="folder-name">所有书签</span>
                        <span class="folder-stats">${rootStats.subfolders}/${rootStats.subbookmarks}</span>
                    </div>
                    <ul class="folder-children" id="root-children" style="display: block;">
                        ${renderChildren('root', 1)}
                    </ul>
                </li>`;
        }

/** 选择文件夹 */
function selectFolder(folderId, forceRefresh = false) {
    if (currentFolderId === folderId && !forceRefresh) return;
    currentFolderId = folderId;
    renderMainContent();
    closeSidebar();

    // 更新激活状态
    document.querySelectorAll('.folder-item.active').forEach(el => el.classList.remove('active'));
    document.querySelectorAll(`.folder-item[data-id="${folderId}"]`).forEach(item => item.classList.add('active'));
}

/** 切换文件夹展开状态 */
function toggleFolderExpand(folderId) {
    const folder = folders.find(f => f.id === folderId);
    if (folder) {
        folder.expanded = !(folder.expanded || false);
        saveAndRender();
    }
}

/** 渲染主内容区域 */
function renderMainContent() {
    const isTrashView = currentFolderId === 'trash';

    // 更新工具栏
    addBookmarkBtn.classList.toggle('hidden', isTrashView);
    addFolderBtn.classList.toggle('hidden', isTrashView);
    openAllBtn.classList.toggle('hidden', isTrashView);

    // 更新头部
    const folder = folders.find(f => f.id === currentFolderId);
    currentFolderName.textContent = isTrashView ? "回收站" : (folder ? folder.name : "所有书签");
    currentFolderIcon.className = `fas ${isTrashView ? 'fa-trash' : 'fa-folder-open'}`;

    // 渲染内容
    renderFolderPath();
    if (isTrashView) {
        subfoldersContainer.innerHTML = '';
        renderTrashList();
    } else {
        renderSubfolders();
        renderBookmarks();
    }
}

/** 渲染路径导航 */
function renderFolderPath() {
    if (currentFolderId === 'trash') {
        folderPath.innerHTML = '<div class="path-segment">回收站</div>';
        return;
    }
    const pathItems = getFolderPath(currentFolderId);
    folderPath.innerHTML = pathItems.map((item, index) => 
                                         `<div class="path-segment" onclick="selectFolder('${item.id}')">${item.name}</div>`
            ).join('<div class="path-divider">/</div>');
}

/** 渲染子文件夹 */
function renderSubfolders() {
    const subfolders = folders.filter(f => f.parentId === currentFolderId)
    .sort((a, b) => (a.order || 0) - (b.order || 0));

    if (subfolders.length === 0) {
        subfoldersContainer.innerHTML = '';
        return;
    }

    subfoldersContainer.innerHTML = subfolders.map(folder => {
        const stats = getFolderStats(folder.id);
        return `
                <div class="folder-card" data-id="${folder.id}"
                     onclick="selectFolder('${folder.id}')">
                    <div class="folder-card-content">
                        <div class="folder-card-icon"><i class="fas fa-folder"></i></div>
                        <div class="folder-card-name">${folder.name}</div>
                        <div class="folder-card-stats">
                            文件夹: ${stats.subfolders} | 书签: ${stats.subbookmarks}
                        </div>
                    </div>
                    <div class="folder-card-actions" onclick="event.stopPropagation()">
                        <button class="action-btn" onclick="openEditFolderForm('${folder.id}')" title="编辑">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="action-btn" onclick="deleteFolder('${folder.id}')" title="删除">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>`;
            }).join('');
        }

/** 渲染书签列表 */
function renderBookmarks() {
    const currentBookmarks = bookmarks.filter(bm => bm.folderId === currentFolderId)
    .sort((a, b) => (a.order || 0) - (b.order || 0));

    // 更新表头
    bookmarkTableHeader.innerHTML = `
                <tr>
                    <th style="width: 5%;"></th>
                    <th style="width: 10%;">序号</th>
                    <th style="width: 20%;">网站名称</th>
                    <th style="width: 30%;">描述</th>
                    <th style="width: 25%;">网址</th>
                    <th style="width: 10%; text-align: right;">操作</th>
                </tr>`;

            if (currentBookmarks.length === 0) {
                bookmarkList.innerHTML = `
                    <tr>
                        <td colspan="6">
                            <div class="empty-state">
                                <i class="fas fa-bookmark"></i>
                                <h3>此文件夹为空</h3>
                                <p>点击上方按钮添加新书签</p>
                            </div>
                        </td>
                    </tr>`;
                return;
            }

            bookmarkList.innerHTML = currentBookmarks.map((bm, index) => {
                const hasDescription = bm.description && bm.description.trim() !== '';
                return `
                <tr class="bookmark-row" data-id="${bm.id}">
                    <td>
                        <div class="drag-handle" draggable="true"
                             ondragstart="onBookmarkDragStart(event, '${bm.id}')">
                            <i class="fas fa-grip-vertical"></i>
                        </div>
                    </td>
                    <td class="order-number">${index + 1}</td>
                    <td class="bookmark-title" onclick="openBookmark('${bm.url}')">
                        ${bm.title}
                    </td>
                    <td class="bookmark-description" title="${bm.description || ''}">
                        ${hasDescription ? bm.description : ''}
                    </td>
                    <td class="bookmark-url" title="${bm.url}">${bm.url}</td>
                    <td>
                        <div class="bookmark-actions">
                            <button class="action-btn" onclick="openEditBookmarkForm('${bm.id}')" title="编辑">
                                <i class="fas fa-edit"></i>
                            </button>
                            <button class="action-btn" onclick="moveToTrash('${bm.id}')" title="删除">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </td>
                </tr>`;
            }).join('');
        }

/** 渲染回收站列表 */
function renderTrashList() {
    bookmarkTableHeader.innerHTML = `
                <tr>
                    <th style="width: 5%;"></th>
                    <th style="width: 10%;">序号</th>
                    <th style="width: 20%;">网站名称</th>
                    <th style="width: 30%;">描述</th>
                    <th style="width: 25%;">原始路径</th>
                    <th style="width: 10%; text-align: right;">操作</th>
                </tr>`;

            if (trash.length === 0) {
                bookmarkList.innerHTML = `
                    <tr>
                        <td colspan="6">
                            <div class="empty-state">
                                <i class="fas fa-trash-alt"></i>
                                <h3>回收站是空的</h3>
                            </div>
                        </td>
                    </tr>`;
                return;
            }

            bookmarkList.innerHTML = trash.map((item, index) => {
                const pathText = getFolderPath(item.folderId).map(p => p.name).join(' / ');
                return `
                <tr class="bookmark-row" data-id="${item.id}">
                    <td></td>
                    <td class="order-number">${index + 1}</td>
                    <td class="bookmark-title">${item.title}</td>
                    <td class="bookmark-description">${item.description || ''}</td>
                    <td class="bookmark-url" title="${pathText}">${pathText}</td>
                    <td>
                        <div class="bookmark-actions">
                            <button class="action-btn" onclick="restoreFromTrash('${item.id}')" title="恢复">
                                <i class="fas fa-undo"></i>
                            </button>
                            <button class="action-btn" onclick="deletePermanently('${item.id}')" title="永久删除">
                                <i class="fas fa-times-circle"></i>
                            </button>
                        </div>
                    </td>
                </tr>`;
            }).join('');
        }

/** 刷新文件夹选择器 */
function refreshFolderSelectors(selectedId = 'root') {
    const generateOptions = (parentId, level) => {
        const prefix = '&nbsp;&nbsp;'.repeat(level);
        const children = folders.filter(f => f.parentId === parentId)
        .sort((a, b) => (a.order || 0) - (b.order || 0));

        return children.map(f => 
                            `<option value="${f.id}">${prefix}${f.name}</option>${generateOptions(f.id, level + 1)}`
                ).join('');
    };

    const allOptions = `<option value="root">所有书签 (根目录)</option>${generateOptions('root', 0)}`;
    bmFolderSelect.innerHTML = allOptions;
    parentFolderSelect.innerHTML = allOptions;
    bmFolderSelect.value = selectedId;
    parentFolderSelect.value = selectedId;
}

// ==================== 表单操作 ====================
/** 打开添加书签表单 */
function openAddBookmarkForm() {
    hideAllForms();
    document.getElementById('bookmark-form-title').innerHTML = '<i class="fas fa-plus"></i> 添加新书签';
    document.getElementById('bm-id').value = '';
    document.getElementById('bm-title').value = '';
    document.getElementById('bm-url').value = '';
    document.getElementById('bm-description').value = '';
    refreshFolderSelectors(currentFolderId);
    bookmarkFormContainer.classList.add('active');
}

/** 打开编辑书签表单 */
function openEditBookmarkForm(id) {
    const bookmark = bookmarks.find(b => b.id === id);
    if (!bookmark) return;

    hideAllForms();
    document.getElementById('bookmark-form-title').innerHTML = '<i class="fas fa-edit"></i> 编辑书签';
    document.getElementById('bm-id').value = bookmark.id;
    document.getElementById('bm-title').value = bookmark.title;
    document.getElementById('bm-url').value = bookmark.url;
    document.getElementById('bm-description').value = bookmark.description || '';
    refreshFolderSelectors(bookmark.folderId);
    bookmarkFormContainer.classList.add('active');
}

/** 打开添加文件夹表单 */
function openAddFolderForm() {
    hideAllForms();
    document.getElementById('folder-form-title').innerHTML = '<i class="fas fa-folder-plus"></i> 添加新文件夹';
    document.getElementById('folder-id').value = '';
    document.getElementById('folder-name').value = '';
    refreshFolderSelectors(currentFolderId);
    folderFormContainer.classList.add('active');
}

/** 打开编辑文件夹表单 */
function openEditFolderForm(id) {
    const folder = folders.find(f => f.id === id);
    if (!folder) return;

    hideAllForms();
    document.getElementById('folder-form-title').innerHTML = '<i class="fas fa-edit"></i> 重命名文件夹';
    document.getElementById('folder-id').value = folder.id;
    document.getElementById('folder-name').value = folder.name;
    refreshFolderSelectors(folder.parentId);
    folderFormContainer.classList.add('active');
}

/** 保存书签 */
async function saveBookmark() {
    const id = document.getElementById('bm-id').value;
    const title = document.getElementById('bm-title').value.trim();
    const url = document.getElementById('bm-url').value.trim();
    const description = document.getElementById('bm-description').value.trim();
    const folderId = document.getElementById('bm-folder').value;

    if (!title || !url) {
        showToast('标题和网址不能为空!', 'error');
        return;
    }
    if (!url.match(/^https?:\/\//)) {
        showToast('网址格式不正确，必须以http://或https://开头', 'error');
        return;
    }

    let operation = '';
    try {
        if (id) {
            // 更新现有书签
            const index = bookmarks.findIndex(b => b.id === id);
            if (index > -1) {
                bookmarks[index] = { ...bookmarks[index], title, url, description, folderId };
                operation = '更新';
            }
        } else {
            // 添加新书签
            const newBookmark = {
                id: generateId(),
                title,
                url,
                description,
                folderId,
                order: bookmarks.filter(b => b.folderId === folderId).length
            };
            bookmarks.push(newBookmark);
            operation = '添加';
        }
        
        hideAllForms();
        
        // 先更新本地UI
        renderApp();
        
        // 然后尝试保存到云端
        if (window.currentGistConfig && encryptionKey) {
            try {
                const success = await updateGistWithConfig(
                    window.currentGistConfig.url,
                    window.currentGistConfig.token
                );
                
                if (success) {
                    showToast(`书签已${operation}并保存到云端`, 'success');
                }
                // 如果失败，updateGistWithConfig 已经显示了错误信息
            } catch (saveError) {
                // 本地已更新，但云端保存失败
                showToast(`书签已${operation}（本地），云端保存失败：${saveError.message}`, 'warning');
            }
        } else {
            // 只更新本地
            showToast(`书签已${operation}（仅本地）`, 'success');
        }
        
    } catch (error) {
        console.error(`书签${operation}失败:`, error);
        showToast(`书签${operation}失败: ${error.message}`, 'error');
    }
}

/** 保存文件夹 */
async function saveFolder() {
    const id = document.getElementById('folder-id').value;
    const name = document.getElementById('folder-name').value.trim();
    const parentId = document.getElementById('parent-folder').value;

    if (!name) {
        showToast('文件夹名称不能为空!', 'error');
        return;
    }

    if (id) {
        // 更新现有文件夹
        const index = folders.findIndex(f => f.id === id);
        if (index > -1) {
            folders[index] = { ...folders[index], name, parentId };
            showToast('文件夹已更新', 'success');
        }
    } else {
        // 添加新文件夹
        const newFolder = {
            id: generateId(),
            name,
            parentId,
            expanded: false,
            order: folders.filter(f => f.parentId === parentId).length
        };
        folders.push(newFolder);
        showToast('文件夹已创建', 'success');
    }

    hideAllForms();
    await saveAndRender();
}

// ==================== 删除操作 ====================
/** 删除文件夹 */
function deleteFolder(folderId) {
    const hasChildren = folders.some(f => f.parentId === folderId);
    const hasBookmarks = bookmarks.some(b => b.folderId === folderId);

    if (hasChildren || hasBookmarks) {
        showToast('请先清空文件夹内容', 'error');
        return;
    }

    if (confirm('确定要删除这个文件夹吗？')) {
        folders = folders.filter(f => f.id !== folderId);
        if (currentFolderId === folderId) currentFolderId = 'root';
        saveAndRender();
        showToast('文件夹已删除', 'success');
    }
}

/** 移动到回收站 */
async function moveToTrash(bookmarkId) {
    const index = bookmarks.findIndex(bm => bm.id === bookmarkId);
    if (index > -1) {
        const [item] = bookmarks.splice(index, 1);
        trash.unshift(item);
        await saveAndRender();
        showToast('书签已移至回收站', 'success');
    }
}

/** 从回收站恢复 */
async function restoreFromTrash(id) {
    const index = trash.findIndex(item => item.id === id);
    if (index > -1) {
        const [item] = trash.splice(index, 1);

        // 检查原文件夹是否存在
        if (item.folderId !== 'root' && !folders.some(f => f.id === item.folderId)) {
            item.folderId = 'root';
            showToast('书签已恢复至根目录', 'warning');
        } else {
            showToast('书签已恢复', 'success');
        }

        bookmarks.push(item);
        await saveAndRender();
    }
}

/** 永久删除 */
async function deletePermanently(id) {
    if (confirm('此操作将永久删除，无法恢复。确定吗？')) {
        trash = trash.filter(item => item.id !== id);
        await saveAndRender();
        showToast('书签已永久删除', 'success');
    }
}

// ==================== 拖放功能 ====================
/** 文件夹拖放相关函数 */
function onFolderDragStart(event, folderId) {
    event.dataTransfer.setData('text/plain', folderId);
    draggedItem = { type: 'folder', id: folderId };
    event.target.closest('.folder-item').classList.add('dragging');
}

function onFolderDragOver(event, folderId) {
    event.preventDefault();
    if (!draggedItem || draggedItem.id === folderId) return;
    event.currentTarget.classList.add('drop-target');
}

function onFolderDragLeave(event) {
    event.currentTarget.classList.remove('drop-target');
}

async function onFolderDrop(event, targetFolderId) {
    event.preventDefault();
    event.currentTarget.classList.remove('drop-target');

    if (!draggedItem || draggedItem.type !== 'folder') return;

    const draggedId = draggedItem.id;
    document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));

    await handleFolderDrop(draggedId, targetFolderId);
    draggedItem = null;
}

/** 处理文件夹拖放 */
async function handleFolderDrop(draggedId, targetId) {
    if (draggedId === targetId) return;

    // 检查目标是否是子文件夹
    const isDescendant = (folderId, parentId) => {
        const children = folders.filter(f => f.parentId === parentId);
        for (const child of children) {
            if (child.id === folderId) return true;
            if (isDescendant(folderId, child.id)) return true;
        }
        return false;
    };

    if (isDescendant(targetId, draggedId)) {
        showToast('不能拖到子文件夹中', 'error');
        return;
    }

    const folderIndex = folders.findIndex(f => f.id === draggedId);
    if (folderIndex > -1) {
        folders[folderIndex].parentId = targetId;

        // 重新排序
        const siblings = folders.filter(f => f.parentId === targetId);
        folders[folderIndex].order = siblings.length;

        await saveAndRender();
        showToast('文件夹已移动', 'success');
    }
}

/** 书签拖放相关函数 */
function onBookmarkDragStart(event, bookmarkId) {
    event.dataTransfer.setData('text/plain', bookmarkId);
    draggedItem = { type: 'bookmark', id: bookmarkId };

    // 创建拖拽元素
    const dragEl = document.createElement('div');
    dragEl.innerHTML = '移动书签';
    dragEl.style.position = 'absolute';
    dragEl.style.opacity = '0';
    document.body.appendChild(dragEl);
    event.dataTransfer.setDragImage(dragEl, 0, 0);
    setTimeout(() => dragEl.remove(), 0);

    // 移除所有现有的拖拽指示器
    document.querySelectorAll('.drop-indicator.show').forEach(el => el.remove());
}

function onBookmarkDragOver(event, bookmarkId) {
    event.preventDefault();
    if (!draggedItem || draggedItem.id === bookmarkId) return;

    // 计算插入位置
    const row = event.target.closest('tr');
    if (!row) return;

    const rect = row.getBoundingClientRect();
    const offset = event.clientY - rect.top;
    const isBefore = offset < rect.height / 2;

    // 移除旧的指示器
    document.querySelectorAll('.drop-indicator.show').forEach(el => el.remove());

    // 创建新的指示器
    const indicator = document.createElement('div');
    indicator.className = 'drop-indicator show';
    indicator.style.position = 'absolute';
    indicator.style.left = '0';
    indicator.style.right = '0';
    indicator.style.height = '2px';
    indicator.style.backgroundColor = 'var(--primary-color)';
    indicator.style.zIndex = '1000';

    if (isBefore) {
        indicator.style.top = `${rect.top}px`;
    } else {
        indicator.style.top = `${rect.bottom}px`;
    }

    document.body.appendChild(indicator);
    dragOverItem = { 
        type: 'bookmark', 
        id: bookmarkId, 
        position: isBefore ? 'before' : 'after' 
    };
}

function onBookmarkDragLeave(event) {
    // 移除指示器
    document.querySelectorAll('.drop-indicator.show').forEach(el => el.remove());
}

async function onBookmarkDrop(event) {
    event.preventDefault();

    // 移除指示器
    document.querySelectorAll('.drop-indicator.show').forEach(el => el.remove());

    if (!draggedItem || draggedItem.type !== 'bookmark' || !dragOverItem) return;

    await handleBookmarkReorder(draggedItem.id, dragOverItem.id, dragOverItem.position);
    draggedItem = null;
    dragOverItem = null;
}

/** 处理书签重新排序 */
async function handleBookmarkReorder(draggedId, targetId, position) {
    const draggedIndex = bookmarks.findIndex(b => b.id === draggedId);
    const targetIndex = bookmarks.findIndex(b => b.id === targetId);

    if (draggedIndex === -1 || targetIndex === -1) return;

    const draggedBookmark = bookmarks[draggedIndex];
    const targetBookmark = bookmarks[targetIndex];

    // 确保在同一个文件夹
    if (draggedBookmark.folderId !== targetBookmark.folderId) {
        showToast('只能在同文件夹内排序', 'error');
        return;
    }

    // 重新排序
    bookmarks.splice(draggedIndex, 1);
    const newIndex = position === 'before' ? targetIndex : targetIndex + 1;
    bookmarks.splice(newIndex, 0, draggedBookmark);

    // 更新排序值
    const folderBookmarks = bookmarks.filter(b => b.folderId === draggedBookmark.folderId);
    folderBookmarks.forEach((bm, idx) => bm.order = idx);

    await saveAndRender();
    showToast('顺序已更新', 'success');
}

/** 处理书签拖放到文件夹 */
async function handleBookmarkDropToFolder(bookmarkId, folderId) {
    const bookmarkIndex = bookmarks.findIndex(b => b.id === bookmarkId);
    if (bookmarkIndex > -1) {
        bookmarks[bookmarkIndex].folderId = folderId;

        // 在新文件夹中重新排序
        const folderBookmarks = bookmarks.filter(b => b.folderId === folderId);
        bookmarks[bookmarkIndex].order = folderBookmarks.length;

        await saveAndRender();
        showToast('书签已移动', 'success');
    }
}

// ==================== 其他功能 ====================
/** 打开书签 */
function openBookmark(url) {
    if (url) window.open(url, '_blank');
}

/** 打开全部书签 */
function openAllBookmarks() {
    const bookmarksToOpen = bookmarks.filter(bm => bm.folderId === currentFolderId);
    if (bookmarksToOpen.length === 0) {
        showToast('没有书签可以打开', 'warning');
        return;
    }

    if (bookmarksToOpen.length > 5 && !confirm(`即将打开 ${bookmarksToOpen.length} 个标签页，确定吗？`)) {
        return;
    }

    bookmarksToOpen.forEach(bm => window.open(bm.url, '_blank'));
}

// ==================== 认证与初始化 ====================
/** 处理登录 */
async function handleLogin() {
    const password = passwordInput.value;
    if (!password) {
        authError.textContent = '密码不能为空。';
        return;
    }

    encryptionKey = password;

    try {
        // ==================== 第一步：解密配置 ====================
        let decryptedConfig = null;
        try {
            const bytes = CryptoJS.AES.decrypt(ENCRYPTED_CONFIG, password);
            const configText = bytes.toString(CryptoJS.enc.Utf8);

            if (!configText) {
                authError.textContent = '密码错误：无法解密配置';
                encryptionKey = null;
                showToast('配置解密失败', 'error');
                return;
            }

            decryptedConfig = JSON.parse(configText);
            showToast('配置解密成功', 'success');

            // 验证配置完整性
            if (!decryptedConfig.gistId || !decryptedConfig.githubToken) {
                throw new Error('配置格式错误');
            }

        } catch (configError) {
            authError.textContent = '配置解密失败，请检查密码';
            encryptionKey = null;
            showToast('配置格式错误', 'error');
            return;
        }

        // ==================== 第二步：使用解密的配置 ====================
        const GIST_ID = decryptedConfig.gistId;
        const GITHUB_TOKEN = decryptedConfig.githubToken;
        const GIST_URL = `https://api.github.com/gists/${GIST_ID}`;

        // 在登录成功后，设置一个全局变量来保存当前配置
        window.currentGistConfig = {
            url: GIST_URL,
            token: GITHUB_TOKEN
        };

        // 测试 Token 权限
        console.log('测试 Token 权限...');
        try {
            const testResponse = await fetch('https://api.github.com/user', {
                headers: { 'Authorization': `token ${GITHUB_TOKEN}` }
            });
            
            if (!testResponse.ok) {
                console.error('Token 权限测试失败:', testResponse.status, testResponse.statusText);
                showToast('GitHub Token 权限验证失败', 'warning');
            } else {
                const userData = await testResponse.json();
                console.log('Token 权限正常，用户:', userData.login);
            }
        } catch (tokenError) {
            console.error('Token 测试错误:', tokenError);
        }

        // 获取Gist数据
        toggleLoader(authLoader, true);
        const content = await fetchGistWithConfig(GIST_URL, GITHUB_TOKEN);
        toggleLoader(authLoader, false);

        if (content === null) {
            authError.textContent = '无法获取数据';
            encryptionKey = null;
            return;
        }

        // ==================== 第三步：解密Gist数据 ====================
        if (content === '{}') {
            // 新用户，使用当前密码创建新数据
            if (confirm('未找到数据。是否使用当前密码创建新的加密书签库?')) {
                folders = [];
                bookmarks = [];
                trash = [];
                const saveSuccess = await updateGistWithConfig(GIST_URL, GITHUB_TOKEN);
                if (saveSuccess) {
                    showAppView();
                    showToast('新书签库创建成功', 'success');
                } else {
                    showToast('创建失败，请检查Token权限', 'error');
                }
            }
        } else {
            // 解密Gist数据
            const decrypted = decrypt(content, encryptionKey);
            if (!decrypted) {
                authError.textContent = '密码错误：无法解密书签数据';
                encryptionKey = null;
                showToast('书签数据解密失败', 'error');
                return;
            }

            // 加载数据
            const data = JSON.parse(decrypted);
            folders = data.folders || [];
            bookmarks = data.bookmarks || [];
            trash = data.trash || [];

            // 确保数据完整性
            folders.forEach(f => { if (f.order === undefined) f.order = 0; });
            bookmarks.forEach(b => { 
                if (b.order === undefined) b.order = 0;
                if (b.description === undefined) b.description = '';
            });

            showAppView();
            showToast('双重解密成功，数据加载完成', 'success');
        }

    } catch (error) {
        console.error('登录失败:', error);
        authError.textContent = '登录过程中发生错误';
        encryptionKey = null;
        showToast('登录失败', 'error');
    }
}

/** 使用动态配置更新Gist */
async function updateGistWithConfig(gistUrl, githubToken) {
    if (isSaving) {
        console.log('正在保存中，跳过重复请求');
        return false;
    }
    
    isSaving = true;
    
    try {
        const data = {
            folders: folders.map(f => ({ ...f, order: f.order || 0 })),
            bookmarks: bookmarks.map(b => ({ 
                ...b, 
                order: b.order || 0, 
                description: b.description || '' 
            })),
            trash
        };
        
        console.log('准备保存数据到:', gistUrl);
        console.log('Token 前几位:', githubToken.substring(0, 20) + '...');
        console.log('数据条数 - 文件夹:', folders.length, '书签:', bookmarks.length);
        
        const encryptedData = encrypt(JSON.stringify(data), encryptionKey);
        
        const response = await fetch(gistUrl, {
            method: 'PATCH',
            headers: {
                'Authorization': `token ${githubToken}`,
                'Content-Type': 'application/json',
                'Accept': 'application/vnd.github.v3+json',
                'User-Agent': 'Encrypted-Bookmark-Manager/1.0'
            },
            body: JSON.stringify({
                description: "加密书签管理器数据",
                files: { 
                    'bookmarks.json': { 
                        content: encryptedData 
                    } 
                }
            })
        });
        
        console.log('保存响应状态:', response.status, response.statusText);
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error('保存失败详细响应:', errorText);
            
            // 根据不同的错误状态提供不同的提示
            if (response.status === 403) {
                throw new Error('403 权限被拒绝：请检查GitHub Token是否有gist权限，或Token是否已过期');
            } else if (response.status === 401) {
                throw new Error('401 认证失败：GitHub Token无效或已过期');
            } else if (response.status === 404) {
                throw new Error('404 Gist不存在：请检查Gist ID是否正确');
            } else {
                throw new Error(`更新失败: ${response.status} ${response.statusText}`);
            }
        }
        
        const result = await response.json();
        console.log('保存成功，Gist ID:', result.id);
        return true;
        
    } catch (error) {
        console.error('保存失败详情:', error);
        showToast(`保存失败: ${error.message}`, 'error');
        return false;
    } finally {
        isSaving = false;
    }
}

/** 登出 */
function handleLogout() {
    encryptionKey = null;
    folders = [];
    bookmarks = [];
    trash = [];
    showAuthView();
    showToast('已锁定', 'info');
}

/** 显示应用界面 */
function showAppView() {
    authContainer.classList.add('hidden');
    appContainer.classList.remove('hidden');
    renderApp();
}

/** 显示认证界面 */
function showAuthView() {
    appContainer.classList.add('hidden');
    authContainer.classList.remove('hidden');
    passwordInput.value = '';
    authError.textContent = '';
}

// ==================== 事件监听 ====================
loginBtn.addEventListener('click', handleLogin);
passwordInput.addEventListener('keyup', (e) => {
    if (e.key === 'Enter') handleLogin();
});

logoutBtn.addEventListener('click', handleLogout);
addBookmarkBtn.addEventListener('click', openAddBookmarkForm);
addFolderBtn.addEventListener('click', openAddFolderForm);
openAllBtn.addEventListener('click', openAllBookmarks);

document.getElementById('save-bookmark-form').addEventListener('click', saveBookmark);
document.getElementById('cancel-bookmark-form').addEventListener('click', hideAllForms);
document.getElementById('save-folder-form').addEventListener('click', saveFolder);
document.getElementById('cancel-folder-form').addEventListener('click', hideAllForms);

// ==================== 全局函数 ====================
window.selectFolder = selectFolder;
window.toggleFolderExpand = toggleFolderExpand;
window.deleteFolder = deleteFolder;
window.openEditFolderForm = openEditFolderForm;
window.openBookmark = openBookmark;
window.openEditBookmarkForm = openEditBookmarkForm;
window.moveToTrash = moveToTrash;
window.restoreFromTrash = restoreFromTrash;
window.deletePermanently = deletePermanently;
window.onFolderDragStart = onFolderDragStart;
window.onFolderDragOver = onFolderDragOver;
window.onFolderDragLeave = onFolderDragLeave;
window.onFolderDrop = onFolderDrop;
window.onBookmarkDragStart = onBookmarkDragStart;
window.onBookmarkDragOver = onBookmarkDragOver;
window.onBookmarkDragLeave = onBookmarkDragLeave;
window.onBookmarkDrop = onBookmarkDrop;
window.toggleSidebar = toggleSidebar;
window.toggleTheme = toggleTheme;

// ==================== 初始化 ====================
initTheme();
showAuthView();
</script>
</body>
</html>
