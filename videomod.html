<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>音频可视化视频生成器</title>
    
    <script>
        const APP_CONFIG = {
            defaultColor: '#7cff4d',    // 默认频谱颜色
            defaultBarCount: 64,        // 默认频谱数量
            defaultOpacity: 1.0,        // 默认不透明度
            defaultBarWidth: 10,        // 默认柱子宽度
            defaultRadius: 5,           // 默认圆角半径
            defaultHeightScale: 300,    // 默认高度缩放系数
            defaultSmooth: 0.8,         // 默认平滑度 (0-0.99)
            fftSize: 2048               // FFT采样大小
        };
    </script>

    <style>
        :root {
            --bg-color: #1e1e1e;
            --panel-bg: #2d2d2d;
            --text-color: #e0e0e0;
            --accent-color: #4caf50;
            --input-bg: #3d3d3d;
            --border-color: #555;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            height: 100vh;
            display: flex;
            overflow: hidden;
        }

        /* 布局结构 */
        .container {
            display: flex;
            width: 100%;
            height: 100%;
        }

        .left-panel {
            width: 350px;
            background-color: var(--panel-bg);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex-shrink: 0;
        }

        .right-panel {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #000;
            padding: 20px;
            position: relative;
        }

        /* 控件样式 */
        h3 { margin: 0 0 10px 0; font-size: 16px; color: var(--accent-color); border-bottom: 1px solid var(--border-color); padding-bottom: 5px;}
        
        .control-group {
            background: #363636;
            padding: 10px;
            border-radius: 8px;
        }

        .row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            gap: 10px;
        }
        
        .row label { font-size: 13px; flex-shrink: 0; }

        input[type="number"], input[type="text"], select {
            background: var(--input-bg);
            border: 1px solid var(--border-color);
            color: white;
            padding: 4px;
            border-radius: 4px;
            width: 60px;
        }
        
        input[type="range"] { flex-grow: 1; cursor: pointer; }
        input[type="color"] { border: none; width: 30px; height: 30px; cursor: pointer; background: none; }

        /* 上传区域特殊样式 */
        .upload-row { display: flex; gap: 10px; }
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            flex: 1;
        }
        .file-input-wrapper input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
        }
        .btn-upload {
            background: var(--input-bg);
            border: 1px dashed var(--border-color);
            color: #aaa;
            padding: 15px;
            text-align: center;
            border-radius: 4px;
            font-size: 13px;
            width: 100%;
            box-sizing: border-box;
            transition: 0.2s;
        }
        .btn-upload:hover { border-color: var(--accent-color); color: var(--accent-color); }
        .file-info { font-size: 12px; color: #888; margin-top: 5px; line-height: 1.4; word-break: break-all;}

        /* 频率范围可视化 */
        .range-visual {
            height: 4px;
            background: #555;
            margin: 5px 0;
            position: relative;
            border-radius: 2px;
        }
        .range-bar {
            position: absolute;
            height: 100%;
            background: var(--accent-color);
            top: 0;
        }

        /* 翻转按钮 */
        .toggle-btn {
            background: var(--input-bg);
            border: 1px solid var(--border-color);
            color: #fff;
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
        }
        .toggle-btn.active { background: var(--accent-color); border-color: var(--accent-color); }

        /* 预览区域 */
        #preview-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><path fill="%23333" d="M0 0h10v10H0zm10 10h10v10H10z"/></svg>') repeat;
        }
        
        canvas {
            max-width: 100%;
            max-height: 80vh;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        /* 底部视频控制 */
        .video-controls {
            margin-top: 15px;
            display: flex;
            gap: 15px;
            align-items: center;
            background: var(--panel-bg);
            padding: 10px 20px;
            border-radius: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .main-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            min-width: 100px;
        }
        .main-btn:disabled { background: #555; cursor: not-allowed; }
        .main-btn.danger { background: #e53935; }
        .main-btn.success { background: #2196f3; }

        .progress-overlay {
            position: absolute;
            bottom: 80px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            display: none;
            z-index: 100;
        }

        /* 滚动条样式 */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-color); }
        ::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #777; }
    </style>
</head>
<body>

<div class="container">
    <div class="left-panel">
        <h3>1. 资源上传</h3>
        <div class="upload-row">
            <div class="file-input-wrapper" id="img-upload-wrapper">
                <div class="btn-upload" id="img-upload-text">拖入/点击图片</div>
                <input type="file" id="img-input" accept="image/*">
            </div>
            <div class="file-input-wrapper" id="audio-upload-wrapper">
                <div class="btn-upload" id="audio-upload-text">拖入/点击音频</div>
                <input type="file" id="audio-input" accept="audio/*">
            </div>
        </div>
        <div id="file-details" class="file-info"></div>

        <h3>2. 频谱外观</h3>
        <div class="control-group">
            <div class="row">
                <label>颜色</label>
                <input type="color" id="bar-color">
                <input type="text" id="bar-color-text" value="#7cff4d" style="width: 70px;">
            </div>
            <div class="row">
                <label>不透明度</label>
                <input type="range" id="opacity-slider" min="0" max="1" step="0.01" value="1">
                <input type="number" id="opacity-input" value="1" step="0.1">
            </div>
            <div class="row">
                <label>高度缩放</label>
                <input type="range" id="height-slider" min="10" max="1000" value="300">
                <input type="number" id="height-input" value="300">
            </div>
            <div class="row">
                <label>柱子宽度</label>
                <input type="range" id="width-slider" min="1" max="100" value="10">
                <input type="number" id="width-input" value="10">
            </div>
             <div class="row">
                <label>圆角半径</label>
                <input type="range" id="radius-slider" min="0" max="50" value="5">
                <input type="number" id="radius-input" value="5">
            </div>
        </div>

        <h3>3. 频谱分布</h3>
        <div class="control-group">
            <div class="row">
                <label>数量</label>
                <input type="range" id="count-slider" min="2" max="256" step="1" value="64">
                <input type="number" id="count-input" value="64">
            </div>
            <div class="row">
                <label>平滑度</label>
                <input type="range" id="smooth-slider" min="0" max="0.99" step="0.01" value="0.8">
                <input type="number" id="smooth-input" value="0.8" step="0.01">
            </div>
            
            <label style="font-size:13px; margin-top:10px; display:block;">频率显示范围 (Hz)</label>
            <div class="range-visual">
                <div class="range-bar" id="freq-range-bar" style="left: 0%; width: 100%;"></div>
            </div>
            <div class="row">
                <input type="number" id="freq-start" value="0" min="0" placeholder="Start">
                <span>-</span>
                <input type="number" id="freq-end" value="20000" min="0" placeholder="End">
            </div>
        </div>

        <h3>4. 翻转设置</h3>
        <div class="control-group">
            <div class="row">
                <label>顶部频谱</label>
                <button class="toggle-btn active" id="btn-top-flip">水平翻转: ON</button>
            </div>
            <div class="row">
                <label>底部频谱</label>
                <button class="toggle-btn" id="btn-bottom-flip">水平翻转: OFF</button>
            </div>
            <div style="font-size: 12px; color: #888; margin-top:5px;">
                * 顶部默认为水平翻转，与底部形成对称美感。
            </div>
        </div>
    </div>

    <div class="right-panel">
        <div id="preview-container">
            <canvas id="main-canvas"></canvas>
        </div>
        
        <div class="progress-overlay" id="render-progress-overlay">
            渲染进度: <span id="render-percent">0%</span>
        </div>

        <div class="video-controls">
            <div class="row" style="margin-bottom:0;">
                <label>分辨率</label>
                <select id="res-select">
                    <option value="auto">自动 (图片尺寸)</option>
                    <option value="1280x720">720p</option>
                    <option value="1920x1080">1080p</option>
                    <option value="2560x1440">2K</option>
                    <option value="3840x2160">4K</option>
                </select>
            </div>
            <div class="row" style="margin-bottom:0;">
                <label>帧率</label>
                <select id="fps-select">
                    <option value="24">24 fps</option>
                    <option value="30" selected>30 fps</option>
                    <option value="60">60 fps</option>
                </select>
            </div>
            <div class="row" style="margin-bottom:0;">
                <label>格式</label>
                <select id="format-select">
                    <option value="mp4">MP4 (推荐)</option>
                    <option value="webm">WebM</option>
                </select>
            </div>

            <div style="width: 1px; height: 20px; background: #555; margin: 0 10px;"></div>

            <button class="main-btn" id="btn-preview">播放预览</button>
            <button class="main-btn" id="btn-render">渲染视频</button>
            <button class="main-btn success" id="btn-export" style="display:none;">导出视频</button>
        </div>
    </div>
</div>

<script>
/**
 * 核心逻辑模块
 */
const App = (function() {
    // 状态管理
    const state = {
        img: null,
        audioBuffer: null,
        audioCtx: null,
        analyser: null,
        sourceNode: null,
        isPlaying: false,
        isRendering: false,
        startTime: 0,
        pauseTime: 0,
        animationId: null,
        renderedBlob: null,
        
        // 参数配置 (初始化为 Config 值)
        params: { ...APP_CONFIG },
        
        // 翻转状态
        flipTop: true,
        flipBottom: false,
        
        // 频率范围
        freqStart: 0,
        freqEnd: 22050 // 默认 Nyquist
    };

    // DOM 元素引用
    const UI = {};
    const canvas = document.getElementById('main-canvas');
    const ctx = canvas.getContext('2d');
    
    // 初始化
    function init() {
        cacheDOM();
        bindEvents();
        resizeCanvas(800, 450); // 默认初始大小
        drawPlaceholder();
        initAudioContext();
        
        // 初始化表单值为配置默认值
        updateUIFromState();
    }

    function cacheDOM() {
        const ids = [
            'img-input', 'audio-input', 'file-details', 
            'bar-color', 'bar-color-text', 'opacity-slider', 'opacity-input',
            'height-slider', 'height-input', 'width-slider', 'width-input',
            'radius-slider', 'radius-input', 'count-slider', 'count-input',
            'smooth-slider', 'smooth-input', 'freq-start', 'freq-end', 'freq-range-bar',
            'btn-top-flip', 'btn-bottom-flip',
            'res-select', 'fps-select', 'format-select',
            'btn-preview', 'btn-render', 'btn-export',
            'render-progress-overlay', 'render-percent',
            'img-upload-wrapper', 'audio-upload-wrapper', 'img-upload-text', 'audio-upload-text'
        ];
        ids.forEach(id => UI[id] = document.getElementById(id));
    }

    function initAudioContext() {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        state.audioCtx = new AudioContext();
        state.analyser = state.audioCtx.createAnalyser();
        state.analyser.fftSize = state.params.fftSize;
        state.analyser.smoothingTimeConstant = state.params.defaultSmooth;
    }

    // --- 事件绑定 ---
    function bindEvents() {
        // 文件上传
        UI['img-input'].addEventListener('change', handleImageUpload);
        UI['audio-input'].addEventListener('change', handleAudioUpload);

        // 基础参数同步绑定 (Input <-> Slider)
        bindDualInput(UI['opacity-slider'], UI['opacity-input'], 'defaultOpacity', false);
        bindDualInput(UI['height-slider'], UI['height-input'], 'defaultHeightScale', false);
        bindDualInput(UI['width-slider'], UI['width-input'], 'defaultBarWidth', false);
        bindDualInput(UI['radius-slider'], UI['radius-input'], 'defaultRadius', false);
        bindDualInput(UI['count-slider'], UI['count-input'], 'defaultBarCount', true); // true for integer
        bindDualInput(UI['smooth-slider'], UI['smooth-input'], 'defaultSmooth', false, (val) => {
            if(state.analyser) state.analyser.smoothingTimeConstant = val;
        });

        // 颜色
        UI['bar-color'].addEventListener('input', (e) => {
            state.params.defaultColor = e.target.value;
            UI['bar-color-text'].value = e.target.value;
            requestDraw();
        });
        UI['bar-color-text'].addEventListener('change', (e) => {
            let val = e.target.value;
            if(!val.startsWith('#')) val = '#' + val;
            if(/^#[0-9A-F]{6}$/i.test(val)) {
                state.params.defaultColor = val;
                UI['bar-color'].value = val;
                requestDraw();
            }
        });

        // 频率范围
        const updateFreq = () => {
            let s = parseInt(UI['freq-start'].value) || 0;
            let e = parseInt(UI['freq-end'].value) || 20000;
            // 简单验证
            if(s < 0) s = 0;
            if(e > 22050) e = 22050; // 假设44.1k采样率
            state.freqStart = s;
            state.freqEnd = e;
            updateFreqRangeVisual();
            requestDraw();
        };
        UI['freq-start'].addEventListener('change', updateFreq);
        UI['freq-end'].addEventListener('change', updateFreq);

        // 翻转按钮
        UI['btn-top-flip'].addEventListener('click', () => {
            state.flipTop = !state.flipTop;
            updateFlipButtons();
            requestDraw();
        });
        UI['btn-bottom-flip'].addEventListener('click', () => {
            state.flipBottom = !state.flipBottom;
            updateFlipButtons();
            requestDraw();
        });

        // 视频预览/控制
        UI['btn-preview'].addEventListener('click', togglePreview);
        UI['res-select'].addEventListener('change', () => {
            resizeCanvasToSelection();
            requestDraw();
        });
        UI['btn-render'].addEventListener('click', startRendering);
        UI['btn-export'].addEventListener('click', exportVideo);
    }

    // 辅助：双向绑定滑块和输入框，处理输入限制逻辑
    function bindDualInput(slider, input, paramKey, isInt, extraCallback) {
        // 滑块拖动：实时更新
        slider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            state.params[paramKey] = val;
            input.value = val; // 滑块拖动时直接更新输入框
            if(extraCallback) extraCallback(val);
            requestDraw();
        });

        // 输入框：输入时不限制，onchange（回车或失焦）时校验并更新
        input.addEventListener('change', (e) => {
            let val = parseFloat(e.target.value);
            const min = parseFloat(slider.min);
            const max = parseFloat(slider.max);
            
            // 钳位
            if (isNaN(val)) val = parseFloat(slider.value);
            if (val < min) val = min;
            if (val > max) val = max;
            
            if (isInt) val = Math.round(val);
            
            // 更新状态
            state.params[paramKey] = val;
            input.value = val;
            slider.value = val;
            
            if(extraCallback) extraCallback(val);
            requestDraw();
        });
    }

    // --- 文件处理 ---
    function handleImageUpload(e) {
        const file = e.target.files[0];
        if (!file) return;

        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => {
            state.img = img;
            
            // UI 更新
            UI['img-upload-text'].textContent = "已加载图片";
            UI['img-upload-wrapper'].style.pointerEvents = "none";
            UI['img-upload-wrapper'].style.opacity = "0.7";
            
            // 自动调整分辨率
            resizeCanvasToSelection();
            requestDraw();
            updateFileInfo();
        };
        img.src = url;
    }

    function handleAudioUpload(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (evt) => {
            state.audioCtx.decodeAudioData(evt.target.result).then(buffer => {
                state.audioBuffer = buffer;
                
                // UI 更新
                UI['audio-upload-text'].textContent = "已加载音频";
                UI['audio-upload-wrapper'].style.pointerEvents = "none";
                UI['audio-upload-wrapper'].style.opacity = "0.7";
                
                // 更新频率范围最大值
                const nyquist = buffer.sampleRate / 2;
                state.freqEnd = Math.min(state.freqEnd, nyquist);
                UI['freq-end'].value = state.freqEnd;
                updateFreqRangeVisual();
                
                updateFileInfo();
                
                // 启用按钮
                UI['btn-preview'].disabled = false;
            });
        };
        reader.readAsArrayBuffer(file);
    }

    function updateFileInfo() {
        let info = "";
        if (state.audioBuffer) {
            const dur = state.audioBuffer.duration.toFixed(2);
            const rate = state.audioBuffer.sampleRate;
            info += `? 音频: ${dur}s | ${rate}Hz <br>`;
        }
        if (state.img) {
            info += `?? 图片: ${state.img.naturalWidth}x${state.img.naturalHeight}`;
        }
        UI['file-details'].innerHTML = info;
    }

    // --- 核心绘图逻辑 ---
    function resizeCanvasToSelection() {
        const val = UI['res-select'].value;
        let w, h;
        if (val === 'auto' && state.img) {
            // 限制最大预览大小，但保持比例。实际渲染时会用真实尺寸。
            // 这里我们设置 Canvas 的内部分辨率为真实分辨率
            w = state.img.naturalWidth;
            h = state.img.naturalHeight;
            // 如果图片太小，给予默认
            if(w < 800) { w=1280; h=720; }
        } else if (val === 'auto') {
            w = 1280; h = 720;
        } else {
            [w, h] = val.split('x').map(Number);
        }
        
        resizeCanvas(w, h);
    }

    function resizeCanvas(w, h) {
        canvas.width = w;
        canvas.height = h;
        // CSS 样式控制显示大小 (contain)
    }

    function drawPlaceholder() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#555';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText("请上传图片和音频以预览", canvas.width/2, canvas.height/2);
    }

    function getFrequencyData() {
        if (!state.analyser) return new Uint8Array(0);
        const dataArray = new Uint8Array(state.analyser.frequencyBinCount);
        state.analyser.getByteFrequencyData(dataArray);
        return dataArray;
    }

    function mapFrequencyToBars(dataArray) {
        // 1. 计算需要的频率范围索引
        // Analyser的频率范围是 0 到 SampleRate/2
        const sampleRate = state.audioCtx.sampleRate;
        const binCount = state.analyser.frequencyBinCount; // 1024
        const maxFreq = sampleRate / 2;
        
        let startIndex = Math.floor(state.freqStart / maxFreq * binCount);
        let endIndex = Math.ceil(state.freqEnd / maxFreq * binCount);
        
        // 边界检查
        startIndex = Math.max(0, startIndex);
        endIndex = Math.min(binCount - 1, endIndex);
        if (endIndex <= startIndex) endIndex = startIndex + 1;

        const slice = dataArray.slice(startIndex, endIndex);
        const bars = [];
        const count = state.params.defaultBarCount;
        
        // 2. 重新采样/平均化以匹配柱子数量
        // 简单的线性插值或区间平均
        const step = slice.length / count;
        
        for (let i = 0; i < count; i++) {
            const start = Math.floor(i * step);
            const end = Math.floor((i + 1) * step);
            let sum = 0;
            let n = 0;
            for (let j = start; j < end && j < slice.length; j++) {
                sum += slice[j];
                n++;
            }
            // 如果区间小于1，直接取最近的点
            if (n === 0) sum = slice[start] || 0;
            else sum /= n;
            
            bars.push(sum);
        }
        return bars;
    }

    function drawFrame() {
        // 清空
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 1. 绘制背景
        if (state.img) {
            ctx.drawImage(state.img, 0, 0, canvas.width, canvas.height);
        } else {
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // 2. 获取数据
        const rawData = getFrequencyData();
        let bars = mapFrequencyToBars(rawData);

        // 3. 绘制频谱
        // 参数准备
        const w = canvas.width;
        const h = canvas.height;
        const count = state.params.defaultBarCount;
        const barW = state.params.defaultBarWidth;
        const color = state.params.defaultColor;
        const opacity = state.params.defaultOpacity;
        const radius = state.params.defaultRadius;
        const scale = state.params.defaultHeightScale;

        // 计算X轴分布：总宽度除以 (count + 1) 个间隙
        // 实际上按照题目要求："三条频谱的对称轴分别是视频横向25%、50%、75%处"
        // 公式：Center_i = Width * (i + 1) / (Count + 1)
        
        ctx.save();
        ctx.fillStyle = color;
        ctx.globalAlpha = opacity;

        // 上部频谱
        const barsTop = state.flipTop ? [...bars].reverse() : bars;
        barsTop.forEach((val, i) => {
            const centerX = w * (i + 1) / (count + 1);
            const height = (val / 255) * scale;
            if (height > 0) {
                // 顶部向下
                // rect(x, y, w, h) -> x是左上角
                const x = centerX - barW / 2;
                const y = 0;
                // 圆角矩形 path
                drawRoundedRect(ctx, x, y, barW, height, radius, 'top');
                ctx.fill();
            }
        });

        // 下部频谱
        const barsBottom = state.flipBottom ? [...bars].reverse() : bars;
        barsBottom.forEach((val, i) => {
            const centerX = w * (i + 1) / (count + 1);
            const height = (val / 255) * scale;
            if (height > 0) {
                // 底部向上
                const x = centerX - barW / 2;
                const y = h - height;
                drawRoundedRect(ctx, x, y, barW, height, radius, 'bottom');
                ctx.fill();
            }
        });

        ctx.restore();
    }

    // 辅助：绘制部分圆角的矩形
    function drawRoundedRect(ctx, x, y, w, h, r, type) {
        // 如果高度小于半径，半径要缩小
        if (h < r) r = h; 
        if (w < 2*r) r = w/2;

        ctx.beginPath();
        if (type === 'top') {
            // 只有下边有两个圆角，或者全圆角？
            // 通常频谱贴边，贴边的一侧是直角，延伸的一侧是圆角
            ctx.moveTo(x, y); 
            ctx.lineTo(x + w, y); // Top Edge (Flat)
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h); // Bottom Right
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r); // Bottom Left
            ctx.lineTo(x, y);
        } else {
            // 底部向上，上边有两个圆角
            ctx.moveTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y); // Top Left
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r); // Top Right
            ctx.lineTo(x + w, y + h);
            ctx.lineTo(x, y + h); // Bottom Edge (Flat)
        }
        ctx.closePath();
    }

    // --- 播放控制 ---
    function togglePreview() {
        if (!state.audioBuffer) return;

        if (state.isPlaying) {
            pausePreview();
        } else {
            playPreview();
        }
    }

    function playPreview() {
        // 创建新的 Source
        state.sourceNode = state.audioCtx.createBufferSource();
        state.sourceNode.buffer = state.audioBuffer;
        state.sourceNode.connect(state.analyser);
        state.analyser.connect(state.audioCtx.destination); // 连接扬声器
        
        // 从暂停处开始
        state.startTime = state.audioCtx.currentTime - state.pauseTime;
        state.sourceNode.start(0, state.pauseTime);
        
        state.isPlaying = true;
        UI['btn-preview'].textContent = "暂停预览";
        
        animate();
        
        state.sourceNode.onended = () => {
             // 只有非手动停止才重置
             if (state.isPlaying) {
                 state.pauseTime = 0;
                 state.isPlaying = false;
                 UI['btn-preview'].textContent = "播放预览";
                 cancelAnimationFrame(state.animationId);
             }
        };
    }

    function pausePreview() {
        if (state.sourceNode) {
            state.sourceNode.stop();
            state.sourceNode.disconnect();
            state.pauseTime = state.audioCtx.currentTime - state.startTime;
            // 循环播放逻辑的话，这里需要取模
            if (state.pauseTime > state.audioBuffer.duration) state.pauseTime = 0;
        }
        state.isPlaying = false;
        UI['btn-preview'].textContent = "播放预览";
        cancelAnimationFrame(state.animationId);
    }

    function animate() {
        drawFrame();
        state.animationId = requestAnimationFrame(animate);
    }

    // 仅绘制一帧（用于调整参数时）
    function requestDraw() {
        if (!state.isPlaying && !state.isRendering) {
            requestAnimationFrame(drawFrame);
        }
    }

    // --- 渲染与导出视频 ---
    // 策略：MediaRecorder + Canvas CaptureStream + 实时静音播放
    async function startRendering() {
        if (!state.audioBuffer || !state.img) {
            alert("请先上传音频和图片");
            return;
        }

        if (state.isRendering) {
            // 取消渲染
            cancelRendering();
            return;
        }

        // 停止预览
        if (state.isPlaying) pausePreview();

        state.isRendering = true;
        
        // 1. 设置画布到目标分辨率
        resizeCanvasToSelection();
        
        // 2. 准备 MediaRecorder
        const fps = parseInt(UI['fps-select'].value);
        const format = UI['format-select'].value;
        const stream = canvas.captureStream(fps);
        
        // 尝试确定 MIME 类型
        let mimeType = 'video/webm;codecs=vp9';
        if (format === 'mp4') {
            // Chrome 支持 video/mp4 (H.264)
            if (MediaRecorder.isTypeSupported('video/mp4;codecs=avc1.42E01E,mp4a.40.2')) {
                mimeType = 'video/mp4;codecs=avc1.42E01E,mp4a.40.2';
            } else if (MediaRecorder.isTypeSupported('video/mp4')) {
                mimeType = 'video/mp4';
            } else {
                console.warn("当前浏览器不支持直接录制 MP4，将回退到 WebM");
            }
        }

        const options = { mimeType: mimeType, videoBitsPerSecond: 8000000 }; // 8Mbps
        let recorder;
        try {
            recorder = new MediaRecorder(stream, options);
        } catch (e) {
            alert("无法创建录制器，可能不支持选定的分辨率或格式。");
            state.isRendering = false;
            return;
        }

        const chunks = [];
        recorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };
        
        recorder.onstop = () => {
            const blob = new Blob(chunks, { type: mimeType });
            state.renderedBlob = blob;
            finishRendering(mimeType);
        };

        // 3. 准备音频播放 (静音)
        // 使用 GainNode 将音量设为 0，防止渲染时听到声音，但 Analyser 仍能收到数据
        const gainNode = state.audioCtx.createGain();
        gainNode.gain.value = 0; // 静音
        
        const source = state.audioCtx.createBufferSource();
        source.buffer = state.audioBuffer;
        
        // 连接：Source -> Analyser -> Gain(0) -> Destination (这是为了保持时间轴流动)
        // 注意：MediaRecorder 录制 Canvas Stream 时不包含音频。
        // 如果需要视频包含音频，需要创建一个 MediaStreamDestination 节点混合音频。
        
        // --- 修正：将音频混合进录制的流中 ---
        const dest = state.audioCtx.createMediaStreamDestination();
        source.connect(state.analyser);
        state.analyser.connect(dest); // 音频进入流
        state.analyser.connect(gainNode); // 同时走静音通道去硬件(如果有必要保持上下文活跃)
        gainNode.connect(state.audioCtx.destination);

        // 将音频轨道添加到视频流中
        const audioTrack = dest.stream.getAudioTracks()[0];
        stream.addTrack(audioTrack);

        // 4. 开始流程
        state.renderingSource = source; // 保存引用以便取消
        UI['btn-render'].textContent = "渲染中 (点击暂停/取消)";
        UI['render-progress-overlay'].style.display = 'block';

        recorder.start();
        source.start(0);

        // 5. 渲染循环 (用于更新 Canvas 和进度条)
        const totalDur = state.audioBuffer.duration;
        const startTime = state.audioCtx.currentTime;

        const renderLoop = () => {
            if (!state.isRendering) return;

            // 绘制当前帧
            drawFrame();

            // 计算进度
            const elapsed = state.audioCtx.currentTime - startTime;
            const percent = Math.min(100, (elapsed / totalDur) * 100).toFixed(1);
            UI['render-percent'].textContent = percent + "%";
            UI['btn-render'].textContent = `渲染中 (${percent}%) 点击暂停`;

            if (elapsed < totalDur) {
                requestAnimationFrame(renderLoop);
            } else {
                // 结束
                recorder.stop();
                source.stop();
            }
        };
        renderLoop();
    }

    function cancelRendering() {
        state.isRendering = false;
        if (state.renderingSource) {
            try { state.renderingSource.stop(); } catch(e){}
        }
        UI['btn-render'].textContent = "渲染视频";
        UI['render-progress-overlay'].style.display = 'none';
        state.renderedBlob = null;
        alert("渲染已取消");
    }

    function finishRendering(mimeType) {
        state.isRendering = false;
        UI['btn-render'].textContent = "播放渲染视频"; // 这里逻辑上稍微变通一下，不做播放器替换了，太复杂
        
        // 实际上，渲染完成后，我们允许导出
        UI['btn-export'].style.display = 'inline-block';
        UI['render-progress-overlay'].style.display = 'none';
        
        // 创建临时预览URL
        const url = URL.createObjectURL(state.renderedBlob);
        
        // 询问用户是否要在当前Canvas区域播放视频？
        // 为了简化，我们直接弹窗或允许下载。
        // 根据需求："点击可在预览窗口查看渲染完成的视频"
        // 我们创建一个 video 元素覆盖 canvas
        showVideoOverlay(url);
    }

    function showVideoOverlay(url) {
        let vid = document.getElementById('preview-video');
        if (!vid) {
            vid = document.createElement('video');
            vid.id = 'preview-video';
            vid.controls = true;
            vid.style.position = 'absolute';
            vid.style.top = '0';
            vid.style.left = '0';
            vid.style.width = '100%';
            vid.style.height = '100%';
            vid.style.zIndex = '10';
            vid.style.background = '#000';
            document.getElementById('preview-container').appendChild(vid);
        }
        vid.src = url;
        vid.style.display = 'block';
        vid.play();
        
        // 绑定一个事件，当点击“渲染视频”按钮时（此时已经是播放状态），如果是重新渲染，要隐藏这个video
        UI['btn-render'].onclick = () => {
            vid.pause();
            vid.style.display = 'none';
            // 恢复原始点击事件
            UI['btn-render'].onclick = startRendering; 
            startRendering();
        };
    }

    function exportVideo() {
        if (!state.renderedBlob) return;
        const a = document.createElement('a');
        a.href = URL.createObjectURL(state.renderedBlob);
        
        // 扩展名判断
        let ext = 'webm';
        if (state.renderedBlob.type.includes('mp4')) ext = 'mp4';
        
        a.download = `viz_video_${Date.now()}.${ext}`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }

    // --- UI 更新辅助 ---
    function updateUIFromState() {
        UI['bar-color'].value = state.params.defaultColor;
        UI['bar-color-text'].value = state.params.defaultColor;
        UI['opacity-slider'].value = state.params.defaultOpacity;
        UI['opacity-input'].value = state.params.defaultOpacity;
        UI['count-slider'].value = state.params.defaultBarCount;
        UI['count-input'].value = state.params.defaultBarCount;
        // ... 其他初始化略，HTML 中 value 已设为默认
        updateFlipButtons();
    }

    function updateFlipButtons() {
        const btnTop = UI['btn-top-flip'];
        const btnBot = UI['btn-bottom-flip'];
        
        btnTop.textContent = `顶部翻转: ${state.flipTop ? 'ON' : 'OFF'}`;
        btnTop.className = state.flipTop ? 'toggle-btn active' : 'toggle-btn';
        
        btnBot.textContent = `底部翻转: ${state.flipBottom ? 'ON' : 'OFF'}`;
        btnBot.className = state.flipBottom ? 'toggle-btn active' : 'toggle-btn';
    }

    function updateFreqRangeVisual() {
        const max = 22050;
        const startP = (state.freqStart / max) * 100;
        const endP = (state.freqEnd / max) * 100;
        const width = endP - startP;
        
        const bar = UI['freq-range-bar'];
        bar.style.left = startP + "%";
        bar.style.width = width + "%";
    }

    return { init };
})();

// 启动应用
window.addEventListener('DOMContentLoaded', App.init);

</script>
</body>
</html>

